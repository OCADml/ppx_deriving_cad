<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ppx_deriving_cad.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ ppx_deriving_cad</nav><header class="odoc-preamble"><h1 id="[@@deriving-cad]"><a href="#[@@deriving-cad]" class="anchor"></a>[@@deriving cad]</h1><p>A PPX deriver that generates functions for the spatial transformation of user defined abstract and record types containing types for which said transformation functions are defined, in particular, the types of the <a href="https://github.com/OCADml/OCADml">OCADml library</a> (<i>e.g.</i> <code>V3.t</code> and <code>V2.t</code>), as well as CAD specific types such as <code>Scad.t</code> of <a href="https://github.com/OCADml/OSCADml">OSCADml</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#api">API</a><ul><li><a href="#derivers">Derivers</a></li></ul></li><li><a href="#usage">Usage</a><ul><li><a href="#mappable">Mappable types</a><ul><li><a href="#mappable_basic">Basic</a></li><li><a href="#mappable_abstract">Abstract</a></li></ul></li><li><a href="#intf_poly">Intf generation and dimensional polymorphism</a></li><li><a href="#attributes">Attributes</a><ul><li><a href="#[@cad.unit]">[@cad.unit]</a></li><li><a href="#[@cad.ignore]">[@cad.ignore]</a></li><li><a href="#cadmap">[@cad.map] and [@cad.mapf]</a></li><li><a href="#dims">[@cad.d2] and [@cad.d3]</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="api"><a href="#api" class="anchor"></a>API</h2><p><a href="Ppx_deriving_cad/index.html"><code>Ppx_deriving_cad</code></a> -- ppx module interface</p><h3 id="derivers"><a href="#derivers" class="anchor"></a>Derivers</h3><ul><li><a href="Ppx_deriving_cad/index.html#val-cad"><code>@@deriving cad</code></a> -- Derives <code>OCADml</code> transformation functions for the derived type</li><li><a href="Ppx_deriving_cad/index.html#val-cad_jane"><code>@@deriving cad_jane</code></a> -- same, but defaulting to janestreet conventions (see <a href="#cadmap"><code>@cad.mapf</code></a>)</li></ul><h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>To generate the suite of basic transformation functions for your type, simply attach <code>[@@deriving cad]</code> (or <code>[@@deriving cad_jane]</code>) to the end.</p><p><b>For example:</b></p><pre><code>open OCADml
open OSCADml

type mark =
  { scad : Scad.d3
  ; centre : V3.t
  }
[@@deriving cad]</code></pre><p><b>Generates:</b></p><pre><code>val translate_mark : V3.t -&gt; mark -&gt; mark
val xtrans_mark : float -&gt; mark -&gt; mark
val ytrans_mark : float -&gt; mark -&gt; mark
val ztrans_mark : float -&gt; mark -&gt; mark
val rotate_mark : ?about:V3.t -&gt; V3.t -&gt; mark -&gt; mark
val xrot_mark : ?about:V3.t -&gt; float -&gt; mark -&gt; mark
val yrot_mark : ?about:V3.t -&gt; float -&gt; mark -&gt; mark
val zrot_mark : ?about:V3.t -&gt; float -&gt; mark -&gt; mark
val axis_rotate_mark : ?about:V3.t -&gt; V3.t -&gt; float -&gt; mark -&gt; mark
val quaternion_mark : ?about:V3.t -&gt; Quaternion.t -&gt; mark -&gt; mark
val scale_mark : V3.t -&gt; mark -&gt; mark
val xscale_mark : float -&gt; mark -&gt; mark
val yscale_mark : float -&gt; mark -&gt; mark
val zscale_mark : float -&gt; mark -&gt; mark
val mirror_mark : V3.t -&gt; mark -&gt; mark
val affine_mark : Affine3.t -&gt; mark -&gt; mark</code></pre><p>If the name of the type being derived is <code>t</code>, then the functions generated (and those required to be present for the types inside of a type/record being derived) will be given unqualified names. For example, applying <code>[@@deriving cad]</code> to a lone record type <code>t</code> would give a module that adhered to the following signature.</p><pre><code>open OCADml
open OSCADml

module Mark : sig
  type t =
    { scad : Scad.d3
    ; centre : V3.t
    }

  val translate : V3.t -&gt; t -&gt; t
  val xtrans : float -&gt; t -&gt; t
  val ytrans : float -&gt; t -&gt; t
  val ztrans : float -&gt; t -&gt; t
  val rotate : ?about:V3.t -&gt; V3.t -&gt; t -&gt; t
  val xrot : ?about:V3.t -&gt; float -&gt; t -&gt; t
  val yrot : ?about:V3.t -&gt; float -&gt; t -&gt; t
  val zrot : ?about:V3.t -&gt; float -&gt; t -&gt; t
  val axis_rotate : ?about:V3.t -&gt; V3.t -&gt; float -&gt; t -&gt; t
  val quaternion : ?about:V3.t -&gt; Quaternion.t -&gt; t -&gt; t
  val scale : V3.t -&gt; t -&gt; t
  val xscale : float -&gt; t -&gt; t
  val yscale : float -&gt; t -&gt; t
  val zscale : float -&gt; t -&gt; t
  val mirror : V3.t -&gt; t -&gt; t
  val affine : Affine3.t -&gt; t -&gt; t
end = struct
  type t =
    { scad : Scad.d3
    ; centre : V3.t
    }
  [@@deriving cad]
end</code></pre><h3 id="mappable"><a href="#mappable" class="anchor"></a>Mappable types</h3><h4 id="mappable_basic"><a href="#mappable_basic" class="anchor"></a>Basic</h4><p>The <code>list</code>, <code>option</code>, and <code>result</code> types, as well as <b>tuples</b>, are automatically mapped over, without any additional annotation or functions provided. Note the set of functions generated here is restricted to those that are strictly relevant to <b>2d</b> shapes/vectors compared to the first examples that contained <b>3d</b> types.</p><pre><code>module Tris : sig
  type t = (V2.t * V2.t * V2.t) list

  val translate : V2.t -&gt; t -&gt; t
  val xtrans : float -&gt; t -&gt; t
  val ytrans : float -&gt; t -&gt; t
  val rotate : ?about:V2.t -&gt; float -&gt; t -&gt; t
  val zrot : ?about:V2.t -&gt; float -&gt; t -&gt; t
  val scale : V2.t -&gt; t -&gt; t
  val xscale : float -&gt; t -&gt; t
  val yscale : float -&gt; t -&gt; t
  val mirror : V2.t -&gt; t -&gt; t
  val affine : Affine2.t -&gt; t -&gt; t
end = struct
  type t = (V2.t * V2.t * V2.t) list [@@deriving cad]
end</code></pre><h4 id="mappable_abstract"><a href="#mappable_abstract" class="anchor"></a>Abstract</h4><p>By default, <code>[@@deriving cad]</code> will attempt to map over constructors other than the above basic types by using applying the <code>map</code> function of the relevant module, or for the non-<code>t</code> named type, using the same naming conventions as explained above.</p><pre><code>module IntMap = Map.Make (Int)

type v3_map = V3.t IntMap.t [@@deriving cad]</code></pre><p>Here, <code>IntMap.map</code> will be used to apply transformations to the contained <code>OCADml.V3.t</code> elements. The expected map function should obey the convention of the function <code>f</code> being the first <i>positional</i> argument. If you are following the conventions of JaneStreet and/or have <code>base</code>/<code>core</code> open, then you may use <code>[@@deriving cad_jane]</code> which defaults to expecting <code>map</code> functions to accept a keyword parameter <code>~f</code> instead. If you are deriving a record containing types with mixed mapping conventions, you can make use of the <code>[@cad.map]</code> and <code>[@cad.mapf]</code> attributes to specify fields that do not match your default convention.</p><p>If the constructor type is not named <code>t</code> as in this example, then this ppx will attempt to use a function with the suffix <code>_map</code>. For example, if the type above was instead <code>V3.t int_map</code>, the function <code>int_map_map</code> will be expected in the scope of the derived type.</p><h3 id="intf_poly"><a href="#intf_poly" class="anchor"></a>Intf generation and dimensional polymorphism</h3><p>Annotating types in module sigs and <code>.mli</code> files will generate the relevant type signatures.</p><pre><code>module PolyScads : sig
  type ('s, 'r, 'a) t =
    { a : ('s, 'r, 'a) Scad.t
    ; b : ('s, 'r, 'a) Scad.t
    }
  [@@deriving cad]
end = struct
  type ('s, 'r, 'a) t =
    { a : ('s, 'r, 'a) Scad.t
    ; b : ('s, 'r, 'a) Scad.t
    }
  [@@deriving cad]
end</code></pre><p>Note that this is also an example of polymorphism over the dimensionality of the <code>OSCADml.Scad.t</code> type. Of course, when the type could be either <b>2d</b> or <b>3d</b>, only <b>2d</b> transformations will be available (translation, rotation, scaling, and mirroring), as in the <a href="#mappable">mappable type example</a>.</p><h3 id="attributes"><a href="#attributes" class="anchor"></a>Attributes</h3><h4 id="[@cad.unit]"><a href="#[@cad.unit]" class="anchor"></a>[@cad.unit]</h4><p>This annotation should be applied to types and record fields which represent unit vector. Types/fields marked with this will not be subject to transformations that would cause them to lose thier identity as such, or rotate about anything other than the world origin. Thus:</p><ul><li>translate and scale will not be applied (identity function instead)</li><li>the <code>?about</code> parameter will not be passed to the rotation functions (<code>rotate</code>, <code>axis_rotate</code>, and <code>quaternion</code>) applied to the type marked by <code>@cad.unit</code>.</li></ul><p><b>For example:</b></p><pre><code>type plane =
  { scad : Scad.d3
  ; normal : V3.t [@cad.unit]
  }
[@@deriving cad]</code></pre><p><b>In this case the following would hold:</b></p><pre><code>let true =
  let plane = { scad = Scad.cube (v3 10. 10. 0.001); normal = v3 0. 0. 1. } in
  let trans = translate_plane (v3 5. 5. 0.) plane in
  V3.equal plane.normal trans.normal</code></pre><h4 id="[@cad.ignore]"><a href="#[@cad.ignore]" class="anchor"></a>[@cad.ignore]</h4><p>This annotation marks a field (in a record, not applicable to abstract types) to be ignored by all generated transformations. This is useful for ignoring whatever flags/configuration data that you want to carry around along with your type for which the relevant functions have not been implemented.</p><pre><code>type mark =
  { scad : Scad.d3
  ; centre : V3.t
  ; id : int [@cad.ignore]
  }
[@@deriving cad]</code></pre><h4 id="cadmap"><a href="#cadmap" class="anchor"></a>[@cad.map] and [@cad.mapf]</h4><p>This annotation marks a type/field for which the transformable type is contained within a mappable type (aka functor), for which <code>map</code> is defined, and whose parameter convention differs from the default specified by the deriver attached to the type declaration.</p><ul><li><code>[@@deriving cad]</code> -&gt; positional <code>f</code> expected (e.g. <code>map f</code>)</li><li><code>[@@deriving cad_jane]</code> -&gt; keyword <code>~f</code> expected (e.g. <code>map ~f</code>)</li></ul><p>Thus, <code>[@cad.map]</code>indicates that relevant <code>map</code> functions will obey the convention of <code>f</code> being the first <i>positional</i> argument (overiding <code>[@@deriving cad_jane]</code>), whereas <code>[@cad.mapf]</code> indicates that a keyword argument of <code>~f</code> is expected instead (overiding <code>[@@deriving cad]</code>). These attributes are not required for the <code>list</code>, <code>option</code>, and <code>result</code> types, as they do not rely on any functions in scope.</p><pre><code>open Base
module IntMap = Caml.Map.Make (Int)
module JaneOption = Option (* aliased since option is special cased *)

module MixedMapConventions : sig
  type t =
    { std : v3 IntMap.t
    ; jane : v3 JaneOption.t
    }
  [@@deriving cad]
end = struct
  type t =
    { std : v3 IntMap.t
    ; jane : v3 JaneOption.t [@cad.mapf]
    }
  [@@deriving cad]
end</code></pre><h4 id="dims"><a href="#dims" class="anchor"></a>[@cad.d2] and [@cad.d3]</h4><p>When the dimensionality of a type is ambiguous (e.g. containing no fields with concretely dimensional types such as <code>Scad.d3</code>, or <code>V2.t</code>), these annotations should be used to specify the correct set of functions/signatures to be generated.</p><pre><code>module AmbiguousDims : sig
  type 'a p =
    { a : 'a [@cad.ignore]
    ; v : v2
    }
  [@@deriving cad]

  type 'a t = { p : 'a p [@cad.d2] } [@@deriving cad]
end = struct
  type 'a p =
    { a : 'a [@cad.ignore]
    ; v : v2
    }
  [@@deriving cad]

  type 'a t = { p : 'a p [@cad.d2] } [@@deriving cad]
end</code></pre><p>Here, there are no <code>OCADml</code> (or related) types present in <code>a' t</code> that can clue <code>[@@deriving cad]</code> into whether it is <b>2d</b> or <b>3d</b>, so we tag on an attribute to clear it up.</p></div></body></html>